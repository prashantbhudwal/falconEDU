import { d as defaultFormatter, a as defaultTransformer, c as createRouterFactory } from './router-f0c73097.mjs';
import { T as TRPCError, g as getTRPCErrorFromUnknown } from './TRPCError-689e79f1.mjs';

/**
 * @internal
 */ function createMiddlewareFactory() {
    function createMiddlewareInner(middlewares) {
        return {
            _middlewares: middlewares,
            unstable_pipe (middlewareBuilderOrFn) {
                const pipedMiddleware = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
                    middlewareBuilderOrFn
                ];
                return createMiddlewareInner([
                    ...middlewares,
                    ...pipedMiddleware
                ]);
            }
        };
    }
    function createMiddleware(fn) {
        return createMiddlewareInner([
            fn
        ]);
    }
    return createMiddleware;
}
const experimental_standaloneMiddleware = ()=>({
        create: createMiddlewareFactory()
    });
function isPlainObject(obj) {
    return obj && typeof obj === 'object' && !Array.isArray(obj);
}
/**
 * @internal
 * Please note, `trpc-openapi` uses this function.
 */ function createInputMiddleware(parse) {
    const inputMiddleware = async (opts)=>{
        let parsedInput;
        const rawInput = await opts.getRawInput();
        try {
            parsedInput = await parse(rawInput);
        } catch (cause) {
            throw new TRPCError({
                code: 'BAD_REQUEST',
                cause
            });
        }
        // Multiple input parsers
        const combinedInput = isPlainObject(opts.input) && isPlainObject(parsedInput) ? {
            ...opts.input,
            ...parsedInput
        } : parsedInput;
        return opts.next({
            input: combinedInput
        });
    };
    inputMiddleware._type = 'input';
    return inputMiddleware;
}
/**
 * @internal
 */ function createOutputMiddleware(parse) {
    const outputMiddleware = async ({ next  })=>{
        const result = await next();
        if (!result.ok) {
            // pass through failures without validating
            return result;
        }
        try {
            const data = await parse(result.data);
            return {
                ...result,
                data
            };
        } catch (cause) {
            throw new TRPCError({
                message: 'Output validation failed',
                code: 'INTERNAL_SERVER_ERROR',
                cause
            });
        }
    };
    outputMiddleware._type = 'output';
    return outputMiddleware;
}

/**
 * Ensures there are no duplicate keys when building a procedure.
 */ function mergeWithoutOverrides(obj1, ...objs) {
    const newObj = Object.assign(Object.create(null), obj1);
    for (const overrides of objs){
        for(const key in overrides){
            if (key in newObj && newObj[key] !== overrides[key]) {
                throw new Error(`Duplicate key ${key}`);
            }
            newObj[key] = overrides[key];
        }
    }
    return newObj;
}

function mergeRouters(...routerList) {
    const record = mergeWithoutOverrides({}, ...routerList.map((r)=>r._def.record));
    const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter)=>{
        if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {
            if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {
                throw new Error('You seem to have several error formatters');
            }
            return nextRouter._def._config.errorFormatter;
        }
        return currentErrorFormatter;
    }, defaultFormatter);
    const transformer = routerList.reduce((prev, current)=>{
        if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {
            if (prev !== defaultTransformer && prev !== current._def._config.transformer) {
                throw new Error('You seem to have several transformers');
            }
            return current._def._config.transformer;
        }
        return prev;
    }, defaultTransformer);
    const router = createRouterFactory({
        errorFormatter,
        transformer,
        isDev: routerList.some((r)=>r._def._config.isDev),
        allowOutsideOfServer: routerList.some((r)=>r._def._config.allowOutsideOfServer),
        isServer: routerList.some((r)=>r._def._config.isServer),
        $types: routerList[0]?._def._config.$types
    })(record);
    return router;
}

function getParseFn(procedureParser) {
    const parser = procedureParser;
    if (typeof parser === 'function') {
        // ParserCustomValidatorEsque
        return parser;
    }
    if (typeof parser.parseAsync === 'function') {
        // ParserZodEsque
        return parser.parseAsync.bind(parser);
    }
    if (typeof parser.parse === 'function') {
        // ParserZodEsque
        // ParserValibotEsque (<= v0.12.X)
        return parser.parse.bind(parser);
    }
    if (typeof parser.validateSync === 'function') {
        // ParserYupEsque
        return parser.validateSync.bind(parser);
    }
    if (typeof parser.create === 'function') {
        // ParserSuperstructEsque
        return parser.create.bind(parser);
    }
    if (typeof parser.assert === 'function') {
        // ParserScaleEsque
        return (value)=>{
            parser.assert(value);
            return value;
        };
    }
    throw new Error('Could not find a validator fn');
}

/**
 * @internal
 */ const middlewareMarker = 'middlewareMarker';
/**
 * @internal
 */ const unsetMarker = Symbol('unsetMarker');

function createNewBuilder(def1, def2) {
    const { middlewares =[] , inputs , meta , ...rest } = def2;
    // TODO: maybe have a fn here to warn about calls
    return createBuilder({
        ...mergeWithoutOverrides(def1, rest),
        inputs: [
            ...def1.inputs,
            ...inputs ?? []
        ],
        middlewares: [
            ...def1.middlewares,
            ...middlewares
        ],
        meta: def1.meta && meta ? {
            ...def1.meta,
            ...meta
        } : meta ?? def1.meta
    });
}
function createBuilder(initDef = {}) {
    const _def = {
        procedure: true,
        inputs: [],
        middlewares: [],
        ...initDef
    };
    return {
        _def,
        input (input) {
            const parser = getParseFn(input);
            return createNewBuilder(_def, {
                inputs: [
                    input
                ],
                middlewares: [
                    createInputMiddleware(parser)
                ]
            });
        },
        output (output) {
            const parseOutput = getParseFn(output);
            return createNewBuilder(_def, {
                output,
                middlewares: [
                    createOutputMiddleware(parseOutput)
                ]
            });
        },
        meta (meta) {
            return createNewBuilder(_def, {
                meta: meta
            });
        },
        use (middlewareBuilderOrFn) {
            // Distinguish between a middleware builder and a middleware function
            const middlewares = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
                middlewareBuilderOrFn
            ];
            return createNewBuilder(_def, {
                middlewares: middlewares
            });
        },
        query (resolver) {
            return createResolver({
                ..._def,
                type: 'query'
            }, resolver);
        },
        mutation (resolver) {
            return createResolver({
                ..._def,
                type: 'mutation'
            }, resolver);
        },
        subscription (resolver) {
            return createResolver({
                ..._def,
                type: 'subscription'
            }, resolver);
        }
    };
}
function createResolver(_def, resolver) {
    const finalBuilder = createNewBuilder(_def, {
        resolver,
        middlewares: [
            async function resolveMiddleware(opts) {
                const data = await resolver(opts);
                return {
                    marker: middlewareMarker,
                    ok: true,
                    data,
                    ctx: opts.ctx
                };
            }
        ]
    });
    return createProcedureCaller(finalBuilder._def);
}
const codeblock = `
If you want to call this function on the server, you do the following:
This is a client-only function.

const caller = appRouter.createCaller({
  /* ... your context */
});

const result = await caller.call('myProcedure', input);
`.trim();
function createProcedureCaller(_def) {
    async function procedure(opts) {
        // is direct server-side call
        if (!opts || !('getRawInput' in opts)) {
            throw new Error(codeblock);
        }
        // run the middlewares recursively with the resolver as the last one
        const callRecursive = async (callOpts = {
            index: 0,
            ctx: opts.ctx
        })=>{
            try {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const middleware = _def.middlewares[callOpts.index];
                const result = await middleware({
                    ctx: callOpts.ctx,
                    type: opts.type,
                    path: opts.path,
                    getRawInput: callOpts.getRawInput ?? opts.getRawInput,
                    meta: _def.meta,
                    input: callOpts.input,
                    next (_nextOpts) {
                        const nextOpts = _nextOpts;
                        return callRecursive({
                            index: callOpts.index + 1,
                            ctx: nextOpts && 'ctx' in nextOpts ? {
                                ...callOpts.ctx,
                                ...nextOpts.ctx
                            } : callOpts.ctx,
                            input: nextOpts && 'input' in nextOpts ? nextOpts.input : callOpts.input,
                            getRawInput: nextOpts && 'getRawInput' in nextOpts ? nextOpts.getRawInput : callOpts.getRawInput
                        });
                    }
                });
                return result;
            } catch (cause) {
                return {
                    ok: false,
                    error: getTRPCErrorFromUnknown(cause),
                    marker: middlewareMarker
                };
            }
        };
        // there's always at least one "next" since we wrap this.resolver in a middleware
        const result = await callRecursive();
        if (!result) {
            throw new TRPCError({
                code: 'INTERNAL_SERVER_ERROR',
                message: 'No result from middlewares - did you forget to `return next()`?'
            });
        }
        if (!result.ok) {
            // re-throw original error
            throw result.error;
        }
        return result.data;
    }
    procedure._def = _def;
    // FIXME typecast shouldn't be needed - fixittt
    return procedure;
}

export { createMiddlewareFactory as a, createInputMiddleware as b, createBuilder as c, createOutputMiddleware as d, experimental_standaloneMiddleware as e, middlewareMarker as f, mergeRouters as m, unsetMarker as u };
