import { T as TRPCError } from './TRPCError-962a4050.js';
import { a as createRecursiveProxy } from './index-8759c3db.js';

/**
 * @internal
 */
function getDataTransformer(transformer) {
    if ('input' in transformer) {
        return transformer;
    }
    return { input: transformer, output: transformer };
}
/**
 * @internal
 */
const defaultTransformer = {
    _default: true,
    input: { serialize: (obj) => obj, deserialize: (obj) => obj },
    output: { serialize: (obj) => obj, deserialize: (obj) => obj },
};

const defaultFormatter = ({ shape, }) => {
    return shape;
};

/**
 * Create an object without inheriting anything from `Object.prototype`
 * @internal
 */
function omitPrototype(obj) {
    return Object.assign(Object.create(null), obj);
}

function isRouter(procedureOrRouter) {
    return 'router' in procedureOrRouter._def;
}
const emptyRouter = {
    _ctx: null,
    _errorShape: null,
    _meta: null,
    queries: {},
    mutations: {},
    subscriptions: {},
    errorFormatter: defaultFormatter,
    transformer: defaultTransformer,
};
/**
 * Reserved words that can't be used as router or procedure names
 */
const reservedWords = [
    /**
     * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
     * since JS will think that `.then` is something that exists
     */
    'then',
];
/**
 * @internal
 */
function createRouterFactory(config) {
    return function createRouterInner(procedures) {
        const reservedWordsUsed = new Set(Object.keys(procedures).filter((v) => reservedWords.includes(v)));
        if (reservedWordsUsed.size > 0) {
            throw new Error('Reserved words used in `router({})` call: ' +
                Array.from(reservedWordsUsed).join(', '));
        }
        const routerProcedures = omitPrototype({});
        function recursiveGetPaths(procedures, path = '') {
            for (const [key, procedureOrRouter] of Object.entries(procedures ?? {})) {
                const newPath = `${path}${key}`;
                if (isRouter(procedureOrRouter)) {
                    recursiveGetPaths(procedureOrRouter._def.procedures, `${newPath}.`);
                    continue;
                }
                if (routerProcedures[newPath]) {
                    throw new Error(`Duplicate key: ${newPath}`);
                }
                routerProcedures[newPath] = procedureOrRouter;
            }
        }
        recursiveGetPaths(procedures);
        const _def = {
            _config: config,
            router: true,
            procedures: routerProcedures,
            ...emptyRouter,
            record: procedures,
        };
        const router = {
            ...procedures,
            _def,
            createCaller(ctx) {
                const proxy = createRecursiveProxy(({ path, args }) => {
                    const fullPath = path.join('.');
                    const procedure = _def.procedures[fullPath];
                    return procedure({
                        path: fullPath,
                        getRawInput: async () => args[0],
                        ctx,
                        type: procedure._def.type,
                    });
                });
                return proxy;
            },
        };
        return router;
    };
}
function isProcedure(procedureOrRouter) {
    return !!procedureOrRouter._def.procedure;
}
/**
 * @internal
 */
function callProcedure(opts) {
    const { type, path } = opts;
    const proc = opts.procedures[path];
    if (!proc || !isProcedure(proc) || proc._def.type !== type) {
        throw new TRPCError({
            code: 'NOT_FOUND',
            message: `No "${type}"-procedure on path "${path}"`,
        });
    }
    return proc(opts);
}

export { defaultTransformer as a, callProcedure as b, createRouterFactory as c, defaultFormatter as d, getDataTransformer as g };
