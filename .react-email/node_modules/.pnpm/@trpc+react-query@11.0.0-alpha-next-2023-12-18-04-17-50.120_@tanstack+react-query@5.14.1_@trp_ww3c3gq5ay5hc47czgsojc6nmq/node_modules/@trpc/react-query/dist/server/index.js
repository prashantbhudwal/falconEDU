'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reactQuery = require('@tanstack/react-query');
var client = require('@trpc/client');
var server = require('@trpc/server');
var shared = require('@trpc/server/shared');
var utilsProxy = require('../utilsProxy-27bd93c1.js');
require('react');
var queryClient = require('../queryClient-358a9a75.js');

/**
 * Create functions you can use for server-side rendering / static generation
 * @see https://trpc.io/docs/client/nextjs/server-side-helpers
 */ function createServerSideHelpers(opts) {
    const queryClient$1 = queryClient.getQueryClient(opts);
    const resolvedOpts = (()=>{
        if ('router' in opts) {
            const { transformer , ctx , router  } = opts;
            return {
                serialize: transformer ? ('input' in transformer ? transformer.input : transformer).serialize : (obj)=>obj,
                query: (queryOpts)=>{
                    return server.callProcedure({
                        procedures: router._def.procedures,
                        path: queryOpts.path,
                        getRawInput: async ()=>queryOpts.input,
                        ctx,
                        type: 'query'
                    });
                }
            };
        }
        const { client: client$1  } = opts;
        const untypedClient = client$1 instanceof client.TRPCUntypedClient ? client$1 : client.getUntypedClient(client$1);
        return {
            query: (queryOpts)=>untypedClient.query(queryOpts.path, queryOpts.input),
            serialize: (obj)=>untypedClient.runtime.transformer.serialize(obj)
        };
    })();
    function _dehydrate(opts = {
        shouldDehydrateQuery () {
            // makes sure to serialize errors
            return true;
        }
    }) {
        const before = reactQuery.dehydrate(queryClient$1, opts);
        const after = resolvedOpts.serialize(before);
        return after;
    }
    return shared.createFlatProxy((key)=>{
        if (key === 'queryClient') return queryClient$1;
        if (key === 'dehydrate') return _dehydrate;
        return shared.createRecursiveProxy((opts)=>{
            const args = opts.args;
            const input = args[0];
            const arrayPath = [
                key,
                ...opts.path
            ];
            const utilName = arrayPath.pop();
            const queryFn = ()=>resolvedOpts.query({
                    path: arrayPath.join('.'),
                    input
                });
            const queryKey = utilsProxy.getQueryKeyInternal(arrayPath, input, utilsProxy.getQueryType(utilName));
            const helperMap = {
                fetch: ()=>{
                    const args1 = args[1];
                    return queryClient$1.fetchQuery({
                        ...args1,
                        queryKey,
                        queryFn
                    });
                },
                fetchInfinite: ()=>{
                    const args1 = args[1];
                    return queryClient$1.fetchInfiniteQuery({
                        ...args1,
                        queryKey,
                        queryFn,
                        initialPageParam: args1?.initialCursor ?? null
                    });
                },
                prefetch: ()=>{
                    const args1 = args[1];
                    return queryClient$1.prefetchQuery({
                        ...args1,
                        queryKey,
                        queryFn
                    });
                },
                prefetchInfinite: ()=>{
                    const args1 = args[1];
                    return queryClient$1.prefetchInfiniteQuery({
                        ...args1,
                        queryKey,
                        queryFn,
                        initialPageParam: args1?.initialCursor ?? null
                    });
                }
            };
            return helperMap[utilName]();
        });
    });
}

exports.createServerSideHelpers = createServerSideHelpers;
