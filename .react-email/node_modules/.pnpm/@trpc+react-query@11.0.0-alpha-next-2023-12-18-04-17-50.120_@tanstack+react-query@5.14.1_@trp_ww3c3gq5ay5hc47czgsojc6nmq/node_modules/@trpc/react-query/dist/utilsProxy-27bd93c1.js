'use strict';

var client = require('@trpc/client');
var shared = require('@trpc/server/shared');
var React = require('react');

/**
 * To allow easy interactions with groups of related queries, such as
 * invalidating all queries of a router, we use an array as the path when
 * storing in tanstack query.
 **/ function getQueryKeyInternal(path, input, type) {
    // Construct a query key that is easy to destructure and flexible for
    // partial selecting etc.
    // https://github.com/trpc/trpc/issues/3128
    // some parts of the path may be dot-separated, split them up
    const splitPath = path.flatMap((part)=>part.split('.'));
    if (!input && (!type || type === 'any')) // for `utils.invalidate()` to match all queries (including vanilla react-query)
    // we don't want nested array if path is empty, i.e. `[]` instead of `[[]]`
    return splitPath.length ? [
        splitPath
    ] : [];
    return [
        splitPath,
        {
            ...typeof input !== 'undefined' && {
                input: input
            },
            ...type && type !== 'any' && {
                type: type
            }
        }
    ];
}
/**
 * Method to extract the query key for a procedure
 * @param procedureOrRouter - procedure or AnyRouter
 * @param input - input to procedureOrRouter
 * @param type - defaults to `any`
 * @link https://trpc.io/docs/getQueryKey
 */ function getQueryKey(..._params) {
    const [procedureOrRouter, input, type] = _params;
    // @ts-expect-error - we don't expose _def on the type layer
    const path = procedureOrRouter._def().path;
    const queryKey = getQueryKeyInternal(path, input, type ?? 'any');
    return queryKey;
}

const contextProps = [
    'client',
    'ssrContext',
    'ssrState',
    'abortOnUnmount'
];
const TRPCContext = /*#__PURE__*/ React.createContext(null);

const getQueryType = (utilName)=>{
    switch(utilName){
        case 'fetch':
        case 'ensureData':
        case 'prefetch':
        case 'getData':
        case 'setData':
            return 'query';
        case 'fetchInfinite':
        case 'prefetchInfinite':
        case 'getInfiniteData':
        case 'setInfiniteData':
            return 'infinite';
        case 'cancel':
        case 'invalidate':
        case 'refetch':
        case 'reset':
            return 'any';
    }
};
/**
 * @internal
 */ function createReactQueryUtils(context) {
    return shared.createFlatProxy((key)=>{
        const contextName = key;
        if (contextName === 'client') {
            return client.createTRPCClientProxy(context.client);
        }
        if (contextProps.includes(contextName)) {
            return context[contextName];
        }
        return shared.createRecursiveProxy((opts)=>{
            const path = [
                key,
                ...opts.path
            ];
            const utilName = path.pop();
            const args = [
                ...opts.args
            ];
            const input = args.shift(); // args can now be spread when input removed
            const queryType = getQueryType(utilName);
            const queryKey = getQueryKeyInternal(path, input, queryType);
            const contextMap = {
                fetch: ()=>context.fetchQuery(queryKey, ...args),
                fetchInfinite: ()=>context.fetchInfiniteQuery(queryKey, args[0]),
                prefetch: ()=>context.prefetchQuery(queryKey, ...args),
                prefetchInfinite: ()=>context.prefetchInfiniteQuery(queryKey, args[0]),
                ensureData: ()=>context.ensureQueryData(queryKey, ...args),
                invalidate: ()=>context.invalidateQueries(queryKey, ...args),
                reset: ()=>context.resetQueries(queryKey, ...args),
                refetch: ()=>context.refetchQueries(queryKey, ...args),
                cancel: ()=>context.cancelQuery(queryKey, ...args),
                setData: ()=>{
                    context.setQueryData(queryKey, args[0], args[1]);
                },
                setInfiniteData: ()=>{
                    context.setInfiniteQueryData(queryKey, args[0], args[1]);
                },
                getData: ()=>context.getQueryData(queryKey),
                getInfiniteData: ()=>context.getInfiniteQueryData(queryKey)
            };
            return contextMap[utilName]();
        });
    });
}

exports.TRPCContext = TRPCContext;
exports.contextProps = contextProps;
exports.createReactQueryUtils = createReactQueryUtils;
exports.getQueryKey = getQueryKey;
exports.getQueryKeyInternal = getQueryKeyInternal;
exports.getQueryType = getQueryType;
