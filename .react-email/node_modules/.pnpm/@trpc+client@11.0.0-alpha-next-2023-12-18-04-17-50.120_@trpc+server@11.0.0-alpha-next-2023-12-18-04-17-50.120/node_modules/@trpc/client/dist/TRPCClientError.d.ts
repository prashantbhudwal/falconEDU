import { DefaultErrorShape } from '@trpc/server';
import { TRPCErrorResponse } from '@trpc/server/rpc';
import { inferErrorShape, TRPCInferrable } from '@trpc/server/shared';
import { Maybe } from '@trpc/server/unstableInternalsExport';
export interface TRPCClientErrorBase<TShape extends DefaultErrorShape> {
    readonly message: string;
    readonly shape: Maybe<TShape>;
    readonly data: Maybe<TShape['data']>;
}
export type TRPCClientErrorLike<TInferrable extends TRPCInferrable> = TRPCClientErrorBase<inferErrorShape<TInferrable>>;
export declare class TRPCClientError<TRouterOrProcedure extends TRPCInferrable> extends Error implements TRPCClientErrorBase<inferErrorShape<TRouterOrProcedure>> {
    readonly cause: Error | undefined;
    readonly shape: Maybe<inferErrorShape<TRouterOrProcedure>>;
    readonly data: Maybe<inferErrorShape<TRouterOrProcedure>['data']>;
    /**
     * Additional meta data about the error
     * In the case of HTTP-errors, we'll have `response` and potentially `responseJSON` here
     */
    meta: Record<string, unknown> | undefined;
    constructor(message: string, opts?: {
        result?: Maybe<inferErrorShape<TRouterOrProcedure>>;
        cause?: Error;
        meta?: Record<string, unknown>;
    });
    static from<TRouterOrProcedure extends TRPCInferrable>(_cause: Error | TRPCErrorResponse<any>, opts?: {
        meta?: Record<string, unknown>;
    }): TRPCClientError<TRouterOrProcedure>;
}
//# sourceMappingURL=TRPCClientError.d.ts.map